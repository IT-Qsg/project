https://www.cnblogs.com/ysocean/p/8032642.html
1.树的实现方式：【广义表的实现，二叉树的实现】
    https://blog.csdn.net/kong_xz/article/details/79484843
    广义表的定义
    广义表简称表，它是线性表的推广。一个广义表是n（n≥0）个元素的一个序列，若n=0时则称为空表。
    设ai为广义表的第i个元素,则广义表GL的一般表示与线性表相同：
     GL=(a1,a2,…,ai,…,an)
    其中n表示广义表的长度，即广义表中所含元素的个数，n≥0。如果ai是单个数据元素，则ai是广义表GL的原子；如果ai是一个广义表，则ai是广义表GL的子表。 

    广义表具有如下重要的特性：
    （1）广义表中的数据元素有相对次序；
    （2）广义表的长度定义为最外层包含元素个数；
    （3）广义表的深度定义为所含括弧的重数。其中原子的深度为0，空表的深度为1；
    （4）广义表可以共享；一个广义表可以为其他广义表共享；这种共享广义表称为再入表；
    （5）广义表可以是一个递归的表。一个广义表可以是自已的子表。这种广义表称为递归表。递归表的深度是无穷值,长度是有限值；
    （6）任何一个非空广义表GL均可分解为表头head(GL) = a1和表尾tail(GL) = ( a2,…,an) 两部分

2.树是一种递归结构，表示方式：孩子表示法，孩子兄弟表示法

3.为什么需要树【抽象数据类型(ADT)】
      1.数组的数据结构，我们知道对于有序数组，查找很快，并介绍可以通过二分法查找，但是想要在有序数组中插入一个数据项，
   就必须先找到插入数据项的位置，然后将所有插入位置后面的数据项全部向后移动一位，来给新数据腾出空间，平均来讲要移动N/2次，
   这是很费时的。同理，删除数据也是。
　　  2.链表，链表的插入和删除很快，我们只需要改变一些引用值就行了，但是查找数据却很慢了，因为不管我们查找什么数据，
   都需要从链表的第一个数据项开始，遍历到找到所需数据项为止，这个查找也是平均需要比较N/2次。
   所以：
　　 那么我们就希望一种数据结构能同时具备数组查找快的优点以及链表插入和删除快的优点，于是 树 诞生了。
4.树的基本概念
    ①、路径：顺着节点的边从一个节点走到另一个节点，所经过的节点的顺序排列就称为“路径”。
　　②、根：树顶端的节点称为根。一棵树只有一个根，如果要把一个节点和边的集合称为树，
        那么从根到其他任何一个节点都必须有且只有一条路径
　　③、父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点
　　④、子节点：一个节点含有的子树的根节点称为该节点的子节点
　　⑤、兄弟节点：具有相同父节点的节点互称为兄弟节点
　　⑥、叶节点：没有子节点的节点称为叶节点，也叫叶子节点
　　⑦、子树：每个节点都可以作为子树的根，它和它所有的子节点、子节点的子节点等都包含在子树中。
　　⑧、节点的层次：从根开始定义，根为第一层，根的子节点为第二层，以此类推。
　　⑨、深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；
　　⑩、高度：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0
     …… 双亲
5.二叉树：树的每个节点最多只能有两个子节点
       1.二叉搜索树要求：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，
    则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。
6.二叉树中有一种特别的树——哈夫曼树（最优二叉树），其通过某种规则（权值）来构造出一哈夫曼二叉树，
在这个二叉树中，只有叶子节点才是有效的数据节点（很重要），其他的非叶子节点是为了构造出哈夫曼而引入的！
    哈夫曼编码是一个通过哈夫曼树进行的一种编码，一般情况下，以字符：‘0’与‘1’表示。编码的实现过程很简单，
    只要实现哈夫曼树，通过遍历哈夫曼树，规定向左子树遍历一个节点编码为“0”，向右遍历一个节点编码为“1”，
    结束条件就是遍历到叶子节点！因为上面说过：哈夫曼树叶子节点才是有效数据节点！
7.红黑树
有如下两个特征：
　　①、节点都有颜色；
　　②、在插入和删除的过程中，要遵循保持这些颜色的不同排列规则
红黑规则：
   【插入或者删除一个节点时，必须要遵守的规则称为红-黑规则】
　　1.每个节点不是红色就是黑色的；
　　2.根节点总是黑色的；
　　3.如果节点是红色的，则它的子节点必须是黑色的（反之不一定）,(也就是从每个叶子到根的所有路径上不能有两个连续的红色节点)；
　　4.从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。
注意：【新插入的节点颜色总是红色的】，这是因为插入一个红色节点比插入一个黑色节点违背红-黑规则的可能性更小，原因是插入黑色节点
总会改变黑色高度（违背规则4），但是插入红色节点只有一半的机会会违背规则3（因为父节点是黑色的没事，父节点是红色的就违背规则3）。
另外违背规则3比违背规则4要更容易修正。当插入一个新的节点时，可能会破坏这种平衡性，那么红-黑树是如何修正的呢？

何时开始旋转：【只要插入节点的父节点都是红色的】
   ①、插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色。
　 ②、插入节点的父节点是红色的，叔叔节点是黑色的，且插入节点是其父节点的右子节点。
　 ③、插入节点的父节点是红色的，叔叔节点是黑色的，且插入节点是其父节点的左子节点。
效率：
红黑树的查找、插入和删除时间复杂度都为O(log2N)，额外的开销是每个节点的存储空间都稍微增加了一点，
因为一个存储红黑树节点的颜色变量【true/false】。插入和删除的时间要增加一个常数因子，因为要进行旋转，
【平均一次插入大约需要一次旋转】，因此插入的时间复杂度还是O(log2N),(时间复杂度的计算要省略常数)，
但实际上比普通的二叉树是要【慢】的。





HashMap:
1.加载因子 0.75
2.使用拉链发解决hash冲突【求取entry键值异或的hash值】，一个hash值对应数组的一个位置
3.使用Node table存储Entry 的链表
      数组加链表
      abstract map
hashtable dictorary


TreeMap:底层实现都是红黑树
entry代表一个节点





